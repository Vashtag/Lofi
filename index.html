<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ambience ‚Äì Seasons & Sounds</title>
<meta name="color-scheme" content="dark light">
<style>
  :root{
    --panel-bg: rgba(18,18,18,.72);
    --panel-border: rgba(255,255,255,.12);
    --text: #e9e9ee;
    --accent: #7bd;
    --accent-2: #f6b26b;
    --muted: #b9c1cb;
    --shadow: 0 10px 30px rgba(0,0,0,.35);

    /* Background image tuning */
    --bg-bright: 1;
    --bg-warmth: 0;
    --bg-sat: 1;
    --bg-blur: 0px;
    --bg-fit: cover;
    --tint-h: 210;      /* hue for season tint */
    --tint-s: 10%;
    --tint-l: 6%;
    --tint-a: .28;
    --bg-image: none;   /* set to url(...) by JS */
  }

  * { box-sizing: border-box; }
  html, body {
    height: 100%;
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    background: #0b0f14;
    color: var(--text);
  }

  /* Scene stack */
  #scene-wrap{
    position: fixed; inset: 0;
    overflow: hidden;
  }
  /* Background image with season tint on its own layer */
  #bg{
    position: absolute; inset: 0;
    background-image:
      linear-gradient(to top,
        hsl(var(--tint-h) var(--tint-s) var(--tint-l) / var(--tint-a)),
        hsl(var(--tint-h) var(--tint-s) var(--tint-l) / var(--tint-a))),
      var(--bg-image);
    background-size: cover, var(--bg-fit);
    background-position: center, center;
    background-repeat: no-repeat, no-repeat;
    filter: brightness(var(--bg-bright)) sepia(var(--bg-warmth)) saturate(var(--bg-sat)) blur(var(--bg-blur));
    will-change: filter, background-image;
  }
  canvas.layer{
    position: absolute; inset: 0; width: 100%; height: 100%;
    display: block;
  }

  /* Control panel */
  .panel{
    position: fixed; left: 1rem; bottom: 1rem; width: min(480px, calc(100vw - 2rem));
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    border-radius: 14px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(8px) saturate(120%);
    padding: .9rem;
    z-index: 3;
  }
  .row{ display: grid; gap: .6rem; margin: .4rem 0 .8rem; }
  .row.cols-2{ grid-template-columns: 1fr 1fr; }
  .row.cols-3{ grid-template-columns: repeat(3, 1fr); }
  .row.align { align-items: center; }
  .label{
    font-weight: 600; letter-spacing: .2px; font-size: .95rem; color: var(--muted);
    display:flex; align-items:center; gap:.45rem;
  }
  .chips{ display: flex; gap: .4rem; flex-wrap: wrap; }
  .chip{
    appearance: none;
    border: 1px solid var(--panel-border);
    background: rgba(255,255,255,.04);
    color: var(--text);
    padding: .45rem .7rem;
    border-radius: 999px;
    cursor: pointer;
    font-weight: 600;
    transition: transform .05s ease, background .2s;
  }
  .chip[aria-pressed="true"]{
    background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.03));
    border-color: rgba(255,255,255,.22);
    outline: 2px solid color-mix(in hsl, var(--accent) 75%, transparent);
  }
  button, .toggle{ cursor: pointer; }
  button.primary{
    background: linear-gradient(180deg, color-mix(in hsl, var(--accent) 70%, transparent), rgba(255,255,255,.05));
    color: #06131d;
    font-weight: 800;
    border: 1px solid rgba(255,255,255,.18);
    border-radius: 10px;
    padding: .6rem .9rem;
  }
  .small{ font-size: .85rem; color: var(--muted); }
  .slider{ display: grid; grid-template-columns: 1fr auto; gap: .6rem; align-items: center; }
  input[type="range"], input[type="text"]{ width: 100%; }
  input[type="file"]{ width: 100%; }
  .switch{ display: inline-flex; align-items: center; gap: .5rem; }
  .section{
    border-top: 1px dashed var(--panel-border);
    margin-top: .6rem; padding-top: .6rem;
  }
  .muted{ color: var(--muted); }
  .disabled{ opacity: .5; pointer-events: none; }

  /* Start gate for audio */
  #gate{
    position: fixed; inset: 0; display: grid; place-items: center;
    background: radial-gradient(1200px circle at 50% 30%, #101820 0%, #080c10 60%, #05070a 100%);
    z-index: 5;
  }
  #gate .card{
    background: rgba(15,18,22,.7);
    border: 1px solid var(--panel-border);
    border-radius: 16px;
    box-shadow: var(--shadow);
    padding: 1.2rem 1.2rem 1rem;
    text-align: center;
    max-width: min(520px, 92vw);
    backdrop-filter: blur(8px) saturate(120%);
  }
  #gate h1{ margin: .2rem 0 .6rem; font-size: 1.4rem; }
  #gate p{ margin: .2rem 0 .9rem; color: var(--muted); }
  #gate button{ font-size: 1.05rem; padding: .7rem 1rem; }

  /* Top-right mini bar */
  #mini{
    position: fixed; right: 1rem; top: 1rem; display:flex; gap:.5rem; z-index:3;
  }
  #mini button{
    border-radius: 999px; padding: .4rem .7rem; border: 1px solid var(--panel-border);
    background: rgba(255,255,255,.05);
    color: var(--text);
  }

  /* Accessibility: prefers-reduced-motion reduces particle count */
  @media (prefers-reduced-motion: reduce){
    :root{ --reduced: 0.55; }
  }
  @media (max-width: 520px){
    .panel{ left:.75rem; right:.75rem; width:auto; }
  }
</style>
</head>
<body>
  <div id="scene-wrap" aria-hidden="true">
    <div id="bg"></div>
    <canvas id="scene" class="layer"></canvas>      <!-- season (snow/leaves/petals/fireflies) & rain splashes -->
    <canvas id="fireplace" class="layer" aria-hidden="true"></canvas> <!-- noise-based flame -->
  </div>

  <div id="mini" role="toolbar" aria-label="Quick actions">
    <button id="btnFull" title="Toggle fullscreen (f)">‚õ∂ Fullscreen</button>
    <button id="btnPause" title="Pause visuals (p)">‚è∏Ô∏é Pause visuals</button>
  </div>

  <div class="panel" role="region" aria-label="Ambience controls">
    <div class="row">
      <div class="label">Season</div>
      <div class="chips" id="seasonChips" role="group" aria-label="Choose season">
        <button class="chip" data-season="winter" aria-pressed="false">Winter ‚ùÑÔ∏è</button>
        <button class="chip" data-season="fall" aria-pressed="false">Fall üçÇ</button>
        <button class="chip" data-season="spring" aria-pressed="false">Spring üå∏</button>
        <button class="chip" data-season="summer" aria-pressed="false">Summer üåô</button>
      </div>
      <div class="small" id="seasonNote"></div>
    </div>

    <div class="row section">
      <div class="label">Background image</div>
      <div class="row">
        <input type="file" id="bgFile" accept="image/*">
        <input type="text" id="bgUrl" placeholder="Paste image URL (https://...)">
        <div class="row cols-3">
          <button id="bgLoad">Load URL</button>
          <button id="bgClear">Clear</button>
          <select id="bgFit" title="Fit">
            <option value="cover" selected>Cover</option>
            <option value="contain">Contain</option>
          </select>
        </div>
      </div>
      <div class="row cols-2">
        <div class="slider"><label for="bgBrightness">BG brightness</label><input type="range" id="bgBrightness" min="40" max="130" value="100"></div>
        <div class="slider"><label for="bgWarmth">Warmth (sepia)</label><input type="range" id="bgWarmth" min="0" max="100" value="18"></div>
      </div>
      <div class="row cols-2">
        <div class="slider"><label for="bgSaturation">Saturation</label><input type="range" id="bgSaturation" min="50" max="200" value="100"></div>
        <div class="slider"><label for="bgBlur">Blur</label><input type="range" id="bgBlur" min="0" max="8" value="0"></div>
      </div>
    </div>

    <div class="row section">
      <div class="label">Sounds</div>
      <div class="row cols-3 align">
        <label class="switch"><input type="checkbox" id="sndRain"> Rain</label>
        <label class="switch"><input type="checkbox" id="sndFire"> Fire crackle</label>
        <label class="switch"><input type="checkbox" id="sndWind"> Wind</label>
      </div>
      <div class="row">
        <div class="slider"><label for="volRain">Rain volume</label><input type="range" id="volRain" min="0" max="100" value="65"></div>
        <div class="slider"><label for="volFire">Fire volume</label><input type="range" id="volFire" min="0" max="100" value="55"></div>
        <div class="slider"><label for="volWind">Wind volume</label><input type="range" id="volWind" min="0" max="100" value="35"></div>
        <div class="slider"><label for="volMaster"><strong>Master volume</strong></label><input type="range" id="volMaster" min="0" max="100" value="70"></div>
      </div>
      <div class="small">Note: Browsers require a click to start audio. Use the button below once.</div>
    </div>

    <div class="row section">
      <div class="label">Visuals</div>
      <div class="slider"><label for="intensity">Scene intensity</label><input type="range" id="intensity" min="10" max="150" value="85"></div>
      <div class="row cols-2 align">
        <label class="switch"><input type="checkbox" id="toggleFireplace"> Fireplace visual</label>
        <label class="switch"><input type="checkbox" id="visRain"> Rain visual</label>
      </div>
      <div class="small muted" id="fireplaceHint">Available in Winter & Fall.</div>
    </div>

    <div class="row section">
      <div class="label">Session</div>
      <div class="row cols-2">
        <button id="btnStartAudio" class="primary">‚ñ∂ Start ambience (enable audio)</button>
        <button id="btnShare">üîó Share this setup</button>
      </div>
      <div class="small">Settings auto-save to your browser and URL.</div>
    </div>
  </div>

  <!-- Start gate (first click to unlock audio) -->
  <div id="gate" aria-modal="true" role="dialog">
    <div class="card">
      <h1>Ambient Seasons</h1>
      <p>Create your atmosphere: choose a season, mix rain, fire crackle, wind, and cozy visuals.<br>Click once to enable sound.</p>
      <button id="gateStart" class="primary">Let‚Äôs begin</button>
      <div class="small" style="margin-top:.6rem;">Tip: press <kbd>F</kbd> for fullscreen, <kbd>P</kbd> to pause visuals.</div>
    </div>
  </div>

<script>
(() => {
  // --------------------------
  // Utilities & State
  // --------------------------
  const $ = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));
  const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const TWO_PI = Math.PI*2;

  const state = {
    season: 'winter',
    intensity: 85,
    fireplace: true,
    visualRain: false,

    // Background
    bg: {
      src: '',               // dataURL or https://...
      fit: 'cover',
      bright: 100,
      warmth: 18,
      sat: 100,
      blur: 0
    },

    // Audio
    sounds: { rain:false, fire:false, wind:false },
    volumes: { rain:65, fire:55, wind:35, master:70 },
    visualsPaused: false
  };

  // Load from URL or localStorage
  const url = new URL(location.href);
  const fromHash = url.hash ? Object.fromEntries(new URLSearchParams(url.hash.slice(1))) : {};
  const saved = JSON.parse(localStorage.getItem('ambience:v2')||'{}');
  Object.assign(state, saved);
  if (Object.keys(fromHash).length){
    state.season = fromHash.season || state.season;
    state.intensity = Number(fromHash.intensity ?? state.intensity);
    state.fireplace = fromHash.fireplace !== undefined ? (String(fromHash.fireplace)==='true' || fromHash.fireplace==='1') : state.fireplace;
    state.visualRain = fromHash.vrvis ? (fromHash.vrvis==='1') : state.visualRain;
    state.sounds.rain = fromHash.rain==='1' || state.sounds.rain;
    state.sounds.fire = fromHash.fire==='1' || state.sounds.fire;
    state.sounds.wind = fromHash.wind==='1' || state.sounds.wind;
    if (fromHash.vr) state.volumes.rain = +fromHash.vr;
    if (fromHash.vf) state.volumes.fire = +fromHash.vf;
    if (fromHash.vw) state.volumes.wind = +fromHash.vw;
    if (fromHash.vm) state.volumes.master = +fromHash.vm;
  }

  // --------------------------
  // Canvas & DPR
  // --------------------------
  const sceneCanvas = $('#scene');
  const fireCanvas  = $('#fireplace');
  const ctx = sceneCanvas.getContext('2d');
  const fctx = fireCanvas.getContext('2d');
  let DPR = Math.max(1, Math.min(2, (window.devicePixelRatio || 1)));

  // üîß Hotfix: declare fireField BEFORE fit() references it.
  let fireField; // will be assigned later

  const fit = () => {
    const w = innerWidth, h = innerHeight;
    for (const c of [sceneCanvas, fireCanvas]) {
      c.width = Math.floor(w * DPR);
      c.height = Math.floor(h * DPR);
      c.style.width = w+'px'; c.style.height = h+'px';
    }
    // Guard: only call after fireField is created
    if (fireField && fireField.resize) fireField.resize();
  };
  fit();
  addEventListener('resize', fit);

  // --------------------------
  // Background image helpers
  // --------------------------
  function applyBackground(){
    $('#bg').style.setProperty('--bg-image', state.bg.src ? `url("${state.bg.src}")` : 'none');
    $('#bg').style.setProperty('--bg-fit', state.bg.fit);
    $('#bg').style.setProperty('--bg-bright', (state.bg.bright/100).toFixed(2));
    $('#bg').style.setProperty('--bg-warmth', (state.bg.warmth/100).toFixed(2));
    $('#bg').style.setProperty('--bg-sat', (state.bg.sat/100).toFixed(2));
    $('#bg').style.setProperty('--bg-blur', `${state.bg.blur}px`);
  }

  // --------------------------
  // Season visuals configuration
  // --------------------------
  const settings = {
    winter: { label: "Winter ‚ùÑÔ∏è", supportsFireplace: true,  tint: [210, "16%", "10%"], baseRate: 0.6 },
    fall:   { label: "Fall üçÇ",   supportsFireplace: true,  tint: [26,  "24%", "10%"], baseRate: 0.45 },
    spring: { label: "Spring üå∏", supportsFireplace: false, tint: [120, "18%", "10%"], baseRate: 0.5 },
    summer: { label: "Summer üåô", supportsFireplace: false, tint: [210, "10%", "8%"],  baseRate: 0.22 }
  };

  function applySeasonTint(){
    const [h,s,l] = settings[state.season].tint;
    document.documentElement.style.setProperty('--tint-h', h);
    document.documentElement.style.setProperty('--tint-s', s);
    document.documentElement.style.setProperty('--tint-l', l);
  }

  // --------------------------
  // Particles: Snow, Leaves, Petals, Fireflies, Rain
  // --------------------------
  let lastTime = performance.now();
  let particles = [];     // leaves, petals, fireflies
  let flakes = [];        // winter snowflakes
  let raindrops = [];     // rain streaks
  let splashes = [];      // rain ripples
  let fireEmbers = [];    // extra embers

  function gust(t){ return Math.sin(t*0.00023)*0.9 + Math.sin(t*0.00013+1.7)*0.6; }

  // --- Snow (pre-rendered sprites)
  const flakeSprites = [];
  function makeFlakeSprites(){
    if (flakeSprites.length) return;
    const defs = [
      (c,s)=>{ const r=s/2; c.translate(r,r); c.beginPath(); for(let i=0;i<6;i++){ const a=i*(Math.PI/3); c.lineTo(Math.cos(a)*r, Math.sin(a)*r);} c.closePath(); c.fill(); },
      (c,s)=>{ const r1=s*0.45, r2=s*0.18; c.translate(s/2,s/2); c.beginPath(); for(let i=0;i<12;i++){ const r=(i%2)?r2:r1; const a=i*(Math.PI/6); c.lineTo(Math.cos(a)*r, Math.sin(a)*r);} c.closePath(); c.fill(); },
      (c,s)=>{ c.beginPath(); c.arc(s/2,s/2,s/2,0,Math.PI*2); c.fill(); }
    ];
    for (let i=0;i<defs.length;i++){
      const s = 24, off = document.createElement('canvas'); off.width = off.height = s;
      const oc = off.getContext('2d'); oc.fillStyle = 'rgba(255,255,255,0.95)'; oc.shadowColor='rgba(255,255,255,0.45)'; oc.shadowBlur=6;
      defs[i](oc, s); flakeSprites.push(off);
    }
  }
  makeFlakeSprites();

  function makeFlake(w,h,t){
    const z = Math.random();
    const size = (0.6 + Math.random()*3.0) * DPR;
    return { x: Math.random()*w, y: -10*DPR, z, r: size, vy: 20+Math.random()*90, vx: 0,
             phase: Math.random()*Math.PI*2, spin: (Math.random()<0.5?-1:1)*(0.006+Math.random()*0.012),
             sprite: flakeSprites[(Math.random()*flakeSprites.length)|0], alpha: 0.85 + Math.random()*0.15 };
  }
  function updateDrawSnow(dt, t, w, h){
    const target = Math.floor((state.intensity/100) * 450 *
      (window.matchMedia('(prefers-reduced-motion: reduce)').matches ? 0.6 : 1));
    while (flakes.length < target) flakes.push(makeFlake(w,h,t));
    while (flakes.length > target) flakes.pop();
    const g = gust(t);
    for (let i=flakes.length-1;i>=0;i--){
      const p = flakes[i];
      p.phase += p.spin*dt;
      const sway = Math.sin(p.phase*1.2)*18;
      p.vx = (g*24) + sway*0.15;
      p.x += p.vx * dt/16;
      p.y += p.vy * dt/16;
      if (p.y > h + 8*DPR) { p.y = -20*DPR; p.x = Math.random()*w; }
      ctx.globalAlpha = p.alpha;
      ctx.drawImage(p.sprite, p.x - p.r*2.5, p.y - p.r*2.5, p.r*5, p.r*5);
      ctx.globalAlpha = 1;
    }
  }

  // Leaves / Petals / Fireflies
  const leafPalette = ['#d1782c','#c45508','#8b3e07','#aa6b24','#b05a2a'];
  const petalPalette = ['#ffd4e0','#ffc6da','#ffe2ea','#ffd8f1','#fff0f5'];
  function makeLeaf(w){ return { kind:'leaf', x: Math.random()*w, y: -60*DPR, s: (6+Math.random()*10)*DPR, vy: 30+Math.random()*65,
                                 rot: Math.random()*TWO_PI, rotSpd: -0.02+Math.random()*0.04, col: leafPalette[(Math.random()*leafPalette.length)|0], alpha: 0.7+Math.random()*0.28 }; }
  function makePetal(w){ return { kind:'petal', x: Math.random()*w, y: -60*DPR, w: (6+Math.random()*8)*DPR, h: (3+Math.random()*4)*DPR,
                                  vy: 24+Math.random()*48, rot: Math.random()*TWO_PI, rotSpd: -0.03+Math.random()*0.06, col: petalPalette[(Math.random()*petalPalette.length)|0], alpha: 0.75+Math.random()*0.22 }; }
  function makeFirefly(w,h){ return { kind:'firefly', x: Math.random()*w, y: Math.random()*h*0.85, r: (1.8+Math.random()*1.6)*DPR,
                                      phase: Math.random()*TWO_PI, speed: 6+Math.random()*10, dir: Math.random()*TWO_PI }; }

  function updateDrawSeason(dt,t,w,h){
    const baseRate = settings[state.season].baseRate;
    const target = Math.floor((state.intensity/100) * 480 * baseRate *
      (window.matchMedia('(prefers-reduced-motion: reduce)').matches ? 0.6 : 1));
    while (particles.length < target){
      if (state.season==='fall') particles.push(makeLeaf(w));
      else if (state.season==='spring') particles.push(makePetal(w));
      else if (state.season==='summer') particles.push(makeFirefly(w,h));
      else break;
    }
    while (particles.length > target) particles.pop();

    const g = gust(t);
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      if (p.kind==='leaf'){
        p.rot += p.rotSpd * dt;
        p.x += (Math.sin(p.rot*1.4)*20 + g*30) * dt/16;
        p.y += p.vy * dt/16;
        if(p.y > h + 12) p.y = -100*DPR, p.x = Math.random()*w;
        ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rot); ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.col; ctx.beginPath(); const s=p.s;
        ctx.moveTo(-s*0.4, 0); ctx.quadraticCurveTo(0, -s*0.8, s*0.5, 0);
        ctx.quadraticCurveTo(0, s*0.8, -s*0.4, 0); ctx.fill(); ctx.restore(); ctx.globalAlpha = 1;
      } else if (p.kind==='petal'){
        p.rot += p.rotSpd * dt;
        p.x += (Math.sin(p.rot*1.1)*18 + g*18) * dt/16;
        p.y += p.vy * dt/16;
        if(p.y > h + 12) p.y = -100*DPR, p.x = Math.random()*w;
        ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rot); ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.col; ctx.beginPath(); ctx.ellipse(0,0,p.w,p.h,0,0,TWO_PI); ctx.fill(); ctx.restore(); ctx.globalAlpha = 1;
      } else { // firefly
        p.phase += dt*0.01; p.x += Math.cos(p.dir)*p.speed*dt/16; p.y += Math.sin(p.dir)*p.speed*dt/16; p.dir += (-0.01+Math.random()*0.02)*dt/16;
        if(p.x<0||p.x>w) p.dir = Math.PI - p.dir; if(p.y<0||p.y>h) p.dir = -p.dir;
        const glow = (Math.sin(p.phase)*0.5+0.5)*0.9+0.1; const r = p.r*(0.8+glow*0.6);
        const g1 = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r*3);
        g1.addColorStop(0, `rgba(255,255,170,${0.9*glow+0.1})`); g1.addColorStop(1, 'rgba(255,255,170,0)');
        ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(p.x, p.y, r*3, 0, TWO_PI); ctx.fill();
      }
    }
  }

  // --- Rain (streaks + splashes)
  function makeDrop(w){
    const speed = (600 + Math.random()*400) * DPR;
    const len = 10 + Math.random()*18;
    return { x: Math.random()*w, y: -20*DPR, vx: 0, vy: speed, len, alpha: 0.5+Math.random()*0.4 };
  }
  function makeSplash(x,y){
    return { x, y, r: 0, max: 6+Math.random()*10, alpha: 0.5+Math.random()*0.3, w: 1+Math.random()*2 };
  }
  function updateDrawRain(dt,t,w,h){
    const rainTarget = state.visualRain ? Math.floor((state.intensity/100) * 900 *
      (window.matchMedia('(prefers-reduced-motion: reduce)').matches ? 0.6 : 1)) : 0;
    while (raindrops.length < rainTarget) raindrops.push(makeDrop(w));
    while (raindrops.length > rainTarget) raindrops.pop();
    const wind = gust(t) * 220;
    ctx.lineWidth = Math.max(1, 1.2*DPR);
    ctx.strokeStyle = 'rgba(200, 220, 255, 0.6)';
    ctx.lineCap = 'round';
    for (let i=raindrops.length-1;i>=0;i--){
      const d = raindrops[i];
      d.vx = wind;
      const dx = d.vx * dt/1000;
      const dy = d.vy * dt/1000;
      ctx.globalAlpha = d.alpha;
      ctx.beginPath();
      ctx.moveTo(d.x, d.y);
      ctx.lineTo(d.x + dx*0.2, d.y + dy*0.2 + d.len*DPR);
      ctx.stroke();
      ctx.globalAlpha = 1;
      d.x += dx; d.y += dy;
      const ground = h*0.85;
      if (d.y > ground){
        splashes.push(makeSplash(d.x, ground + Math.random()*6));
        raindrops.splice(i,1);
      } else if (d.x < -20 || d.x > w+20) {
        raindrops.splice(i,1);
      }
    }
    for (let i=splashes.length-1;i>=0;i--){
      const s = splashes[i];
      s.r += (50 + Math.random()*80) * dt/1000 * DPR;
      s.alpha *= (1 - 0.02*dt/16);
      ctx.globalAlpha = s.alpha;
      ctx.lineWidth = s.w;
      ctx.strokeStyle = 'rgba(220,235,255,0.45)';
      ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, TWO_PI); ctx.stroke();
      ctx.globalAlpha = 1;
      if (s.alpha < 0.02) splashes.splice(i,1);
    }
  }

  // --------------------------
  // Fireplace (noise-based flame + embers)
  // --------------------------
  fireField = (() => {
    let off = document.createElement('canvas');
    let oc = off.getContext('2d', { willReadFrequently: true });
    let ow = 96, oh = 160;
    let t = 0;

    function resize(){
      off.width = ow; off.height = oh;
      oc.imageSmoothingEnabled = true;
      oc.globalCompositeOperation = 'source-over';
    }
    resize();

    function hash(x, y){ const s = Math.sin(x*127.1 + y*311.7)*43758.5453; return (s - Math.floor(s)); }
    function smooth(t){ return t*t*(3-2*t); }
    function valueNoise(x, y){
      const xi = Math.floor(x), yi = Math.floor(y);
      const xf = x - xi,     yf = y - yi;
      const tl = hash(xi, yi), tr = hash(xi+1, yi);
      const bl = hash(xi, yi+1), br = hash(xi+1, yi+1);
      const xt = smooth(xf);
      const top = tl*(1-xt) + tr*xt;
      const bot = bl*(1-xt) + br*xt;
      return top*(1-smooth(yf)) + bot*smooth(yf);
    }
    function fbm(x, y, oct=4){
      let val=0, amp=0.5, freq=1;
      for (let i=0;i<oct;i++){ val += amp*valueNoise(x*freq, y*freq); freq *= 2; amp *= 0.5; }
      return val;
    }

    function step(dt){
      t += dt*0.0012;
      const img = oc.getImageData(0,0,ow,oh);
      const data = img.data;
      for (let j=0;j<oh;j++){
        const v = j/oh;
        for (let i=0;i<ow;i++){
          const u = i/ow;
          const n = fbm(u*3 + Math.sin(t)*0.1, (v*3 - t), 5);
          const shape = Math.max(0, 1 - Math.pow(v, 1.7));
          const heat = Math.max(0, Math.min(1, Math.pow(n, 1.9) * shape));
          let r,g,b,a;
          if (heat < 0.25){ r=40; g=10; b=0; a=heat*0.8; }
          else if (heat < 0.45){ const k=(heat-0.25)/0.2; r=80+(80*k); g=20+(20*k); b=0; a=0.55+0.3*k; }
          else if (heat < 0.7){ const k=(heat-0.45)/0.25; r=160+(70*k); g=60+(50*k); b=10+(10*k); a=0.7+0.2*k; }
          else { const k=(heat-0.7)/0.3; r=230+(25*k); g=160+(80*k); b=30+(170*k); a=0.88+0.08*k; }
          const idx = (j*ow + i)*4;
          data[idx]=r; data[idx+1]=g; data[idx+2]=b; data[idx+3]=Math.floor(255*a);
        }
      }
      oc.putImageData(img, 0, 0);
    }

    function draw(){
      const w = fireCanvas.width, h = fireCanvas.height;
      fctx.clearRect(0,0,w,h);
      const baseY = h*0.88;
      const rg = fctx.createRadialGradient(w*0.5, baseY, 10, w*0.5, baseY, h*0.35);
      rg.addColorStop(0,'rgba(255,170,60,.28)');
      rg.addColorStop(1,'rgba(255,170,60,0)');
      fctx.fillStyle = rg;
      fctx.beginPath(); fctx.arc(w*0.5, baseY, h*0.35, 0, TWO_PI); fctx.fill();

      fctx.globalCompositeOperation = 'lighter';
      const fw = w*0.42, fh = h*0.42;
      fctx.imageSmoothingEnabled = true;
      fctx.drawImage(off, w*0.5 - fw/2, baseY - fh, fw, fh);
      fctx.globalCompositeOperation = 'source-over';

      fctx.fillStyle = '#1a1715';
      fctx.fillRect(w*0.33, baseY+6*DPR, w*0.34, 6*DPR);
      fctx.fillStyle = '#2b231f';
      fctx.fillRect(w*0.28, baseY+10*DPR, w*0.44, 6*DPR);

      fctx.globalCompositeOperation = 'lighter';
      for (let i=fireEmbers.length-1;i>=0;i--){
        const e = fireEmbers[i];
        const age = (performance.now() - e.t0)/1000;
        const life = 1.2 + e.life;
        if (age > life){ fireEmbers.splice(i,1); continue; }
        const k = 1 - age/life;
        const alpha = 0.6*k;
        fctx.fillStyle = `rgba(255,${120+Math.floor(80*k)},40,${alpha})`;
        fctx.beginPath(); fctx.arc(e.x, e.y - age*e.vy, 2*DPR*k, 0, TWO_PI); fctx.fill();
      }
      fctx.globalCompositeOperation = 'source-over';
    }

    return { resize, step, draw };
  })();

  // ensure offscreen field has initial size
  fireField.resize();

  function spawnEmbers(){
    const w = fireCanvas.width, h = fireCanvas.height;
    const baseY = h*0.88, baseX = w*0.5;
    const count = Math.floor((state.intensity/100)*2)+1;
    for (let i=0;i<count;i++){
      fireEmbers.push({ x: baseX + (-70+Math.random()*140)*DPR, y: baseY - 10*DPR, vy: 60+Math.random()*120, t0: performance.now(), life: Math.random()*0.8 });
    }
  }

  // --------------------------
  // Animation loop
  // --------------------------
  function animate(){
    const now = performance.now();
    const dt = clamp(now - lastTime, 8, 48);
    lastTime = now;
    const w = sceneCanvas.width, h = sceneCanvas.height;

    if (!state.visualsPaused){
      ctx.clearRect(0,0,w,h);

      if (state.season === 'winter') updateDrawSnow(dt, now, w, h);

      updateDrawSeason(dt, now, w, h);
      updateDrawRain(dt, now, w, h);

      if (state.fireplace && settings[state.season].supportsFireplace){
        fireField.step(dt);
        fireField.draw();
        if (Math.random() < 0.15) spawnEmbers();
        fireCanvas.style.display = 'block';
      } else {
        fireCanvas.style.display = 'none';
        fireEmbers.length = 0;
        fctx.clearRect(0,0,w,h);
      }
    }

    requestAnimationFrame(animate);
  }

  // --------------------------
  // WebAudio engine
  // --------------------------
  const AudioEngine = (() => {
    let ctx, master;
    const nodes = {};
    function ensure(){
      if (!ctx){
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        master = ctx.createGain(); master.gain.value = state.volumes.master/100;
        master.connect(ctx.destination);
      }
      return ctx;
    }
    function whiteNoiseBuffer(){
      const sr = ctx.sampleRate;
      const buf = ctx.createBuffer(1, sr*2, sr);
      const data = buf.getChannelData(0);
      for (let i=0;i<data.length;i++) data[i] = Math.random()*2 - 1;
      return buf;
    }
    function makeReverbImpulse(seconds=1.8, decay=2.8){
      const rate = ctx.sampleRate, len = rate * seconds;
      const impulse = ctx.createBuffer(2, len, rate);
      for (let c=0;c<2;c++){
        const ch = impulse.getChannelData(c);
        for (let i=0;i<len;i++) ch[i] = (Math.random()*2-1) * Math.pow(1 - i/len, decay);
      }
      return impulse;
    }
    function makeRain(){
      const gain = ctx.createGain(); gain.gain.value = (state.volumes.rain/100) * 0.6;
      const src = ctx.createBufferSource(); src.buffer = whiteNoiseBuffer(); src.loop = true;
      const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 3500;
      const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 200;
      const rev = ctx.createConvolver(); rev.buffer = makeReverbImpulse(1.5, 2.2);
      const del = ctx.createDelay(1.0); del.delayTime.value = 0.22;
      const fb = ctx.createGain(); fb.gain.value = 0.15;
      src.connect(lp); lp.connect(hp); hp.connect(rev);
      rev.connect(del); del.connect(fb); fb.connect(del);
      del.connect(gain); gain.connect(master);
      src.start();
      return { kind:'rain', nodes:{gain, lp, hp, del, fb, rev, src} };
    }
    function makeWind(){
      const gain = ctx.createGain(); gain.gain.value = (state.volumes.wind/100) * 0.4;
      const src = ctx.createBufferSource(); src.buffer = whiteNoiseBuffer(); src.loop = true;
      const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 400; bp.Q.value = 0.6;
      const lfo = ctx.createOscillator(); lfo.frequency.value = 0.15;
      const lfoGain = ctx.createGain(); lfoGain.gain.value = 0.35;
      lfo.connect(lfoGain); lfoGain.connect(bp.frequency);
      src.connect(bp); bp.connect(gain); gain.connect(master);
      src.start(); lfo.start();
      return { kind:'wind', nodes:{gain, src, bp, lfo, lfoGain} };
    }
    function makeFire(){
      const gain = ctx.createGain(); gain.gain.value = (state.volumes.fire/100) * 0.5;
      const hissSrc = ctx.createBufferSource(); hissSrc.buffer = whiteNoiseBuffer(); hissSrc.loop = true;
      const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 1800; bp.Q.value = 0.9;
      hissSrc.connect(bp); bp.connect(gain);
      const crackBus = ctx.createGain(); crackBus.gain.value = 1.0; crackBus.connect(gain);
      function scheduleCrackle(){
        if (!nodes.fire) return;
        const when = ctx.currentTime + Math.random()*0.3;
        const dur = 0.02 + Math.random()*0.08;
        const buf = ctx.createBuffer(1, Math.ceil(ctx.sampleRate*dur), ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i=0;i<data.length;i++){
          const t = i / data.length; const env = Math.pow(1 - t, 3);
          data[i] = (Math.random()*2-1) * env * 0.9;
        }
        const s = ctx.createBufferSource(); s.buffer = buf;
        const bpf = ctx.createBiquadFilter(); bpf.type='bandpass';
        bpf.frequency.value = 1200 + Math.random()*2000; bpf.Q.value = 4;
        const g = ctx.createGain(); g.gain.value = 0.25 + Math.random()*0.5;
        s.connect(bpf); bpf.connect(g); g.connect(crackBus); s.start(when);
        const rate = 20 + (state.intensity/100)*140;
        setTimeout(scheduleCrackle, 1000/rate);
      }
      hissSrc.start(); scheduleCrackle();
      gain.connect(master);
      return { kind:'fire', nodes:{gain, hissSrc, bp, crackBus} };
    }
    function start(kind){
      ensure();
      if (nodes[kind]) return;
      nodes[kind] = (kind==='rain') ? makeRain()
                   : (kind==='wind') ? makeWind()
                   : makeFire();
    }
    function stop(kind){
      const obj = nodes[kind]; if (!obj) return;
      try { if (obj.nodes.src) obj.nodes.src.stop(); if (obj.nodes.hissSrc) obj.nodes.hissSrc.stop(); if (obj.nodes.lfo) obj.nodes.lfo.stop(); } catch(e){}
      Object.values(obj.nodes).forEach(n=>{ try{ n.disconnect(); }catch(e){} });
      delete nodes[kind];
    }
    function setVolume(kind, v){
      if (kind==='master' && master){ master.gain.value = v/100; return; }
      const obj = nodes[kind];
      if (obj && obj.nodes.gain) obj.nodes.gain.gain.value = (v/100) * (kind==='rain'?0.6:kind==='fire'?0.5:0.4);
    }
    async function resume(){ ensure(); if (ctx.state !== 'running') await ctx.resume(); }
    return { start, stop, setVolume, resume };
  })();

  // --------------------------
  // UI Bindings
  // --------------------------
  function saveState(){
    localStorage.setItem('ambience:v2', JSON.stringify(state));
    const qs = new URLSearchParams({
      season: state.season,
      intensity: state.intensity,
      fireplace: state.fireplace,
      vrvis: Number(state.visualRain),
      rain: Number(state.sounds.rain),
      fire: Number(state.sounds.fire),
      wind: Number(state.sounds.wind),
      vr: state.volumes.rain, vf: state.volumes.fire, vw: state.volumes.wind, vm: state.volumes.master
    });
    history.replaceState(null, '', '#'+qs.toString());
  }

  const seasonChips = $('#seasonChips');
  function setSeasonChip(name){ $$('#seasonChips .chip').forEach(c => c.setAttribute('aria-pressed', String(c.dataset.season===name))); }
  function updateFireplaceUI(){
    const supports = settings[state.season].supportsFireplace;
    const t = $('#toggleFireplace');
    t.disabled = !supports;
    $('#fireplaceHint').textContent = supports ? 'Cozy mode is on (toggle to hide).' : 'Available in Winter & Fall.';
    const row = t.closest('.row.cols-2'); if (!supports) row.classList.add('disabled'); else row.classList.remove('disabled');
    if (!supports) state.fireplace = false; t.checked = !!state.fireplace && supports;
  }
  seasonChips.addEventListener('click', (e) => {
    const btn = e.target.closest('.chip'); if (!btn) return;
    state.season = btn.dataset.season;
    setSeasonChip(state.season);
    $('#seasonNote').textContent = settings[state.season].label + ' selected.';
    applySeasonTint();
    updateFireplaceUI();
    saveState();
  });
  setSeasonChip(state.season);
  $('#seasonNote').textContent = settings[state.season].label + ' selected.';
  applySeasonTint(); updateFireplaceUI();

  const bindCheck = (sel, key, sub) => { const el=$(sel); el.checked = !!state[key]; el.addEventListener('change', ()=>{ state[key]=el.checked; if(sub) sub(); saveState(); }); };
  const bindRange = (sel, obj, key, on) => { const el=$(sel); el.value = state[obj]?.[key] ?? state[key]; el.addEventListener('input', ()=>{ if (obj) state[obj][key]=Number(el.value); else state[key]=Number(el.value); if(on) on(); saveState(); }); };

  bindCheck('#toggleFireplace','fireplace', null);
  bindCheck('#visRain','visualRain', null);
  bindRange('#intensity', null,'intensity');

  // Background controls
  bindRange('#bgBrightness','bg','bright', applyBackground);
  bindRange('#bgWarmth','bg','warmth', applyBackground);
  bindRange('#bgSaturation','bg','sat', applyBackground);
  bindRange('#bgBlur','bg','blur', applyBackground);
  $('#bgFit').value = state.bg.fit; $('#bgFit').addEventListener('change', ()=>{ state.bg.fit = $('#bgFit').value; applyBackground(); saveState(); });
  $('#bgClear').addEventListener('click', ()=>{ state.bg.src=''; applyBackground(); saveState(); });
  $('#bgLoad').addEventListener('click', ()=>{
    const u = $('#bgUrl').value.trim();
    if (!u) return;
    state.bg.src = u; applyBackground(); saveState();
  });
  $('#bgFile').addEventListener('change', (e)=>{
    const f = e.target.files?.[0]; if(!f) return;
    const reader = new FileReader();
    reader.onload = () => { state.bg.src = String(reader.result); applyBackground(); saveState(); };
    reader.readAsDataURL(f);
  });
  applyBackground();

  // Sound toggles + volumes
  function bindSoundToggle(id, name){
    const el = $(id); el.checked = !!state.sounds[name];
    el.addEventListener('change', async () => {
      state.sounds[name] = el.checked;
      if (el.checked){ try { await AudioEngine.resume(); } catch(_){} AudioEngine.start(name); AudioEngine.setVolume(name, state.volumes[name]); }
      else { AudioEngine.stop(name); }
      saveState();
    });
  }
  function bindVol(id, name){
    const el = $(id); el.value = state.volumes[name];
    el.addEventListener('input', () => { state.volumes[name] = Number(el.value); AudioEngine.setVolume(name, state.volumes[name]); saveState(); });
  }
  bindSoundToggle('#sndRain','rain'); bindSoundToggle('#sndFire','fire'); bindSoundToggle('#sndWind','wind');
  bindVol('#volRain','rain'); bindVol('#volFire','fire'); bindVol('#volWind','wind'); bindVol('#volMaster','master');

  // üîß Safer: close the gate even if audio resume fails
  async function unlockAudio(){
    try { await AudioEngine.resume(); } catch(e){ console.warn('Audio resume issue:', e); }
    for (const k of ['rain','fire','wind']){
      if (state.sounds[k]) {
        try { AudioEngine.start(k); AudioEngine.setVolume(k, state.volumes[k]); } catch(_) {}
      }
    }
    $('#gate').style.display = 'none';
  }
  $('#gateStart').addEventListener('click', unlockAudio);
  $('#btnStartAudio').addEventListener('click', unlockAudio);

  // Share
  $('#btnShare').addEventListener('click', async () => {
    saveState();
    const shareURL = location.href;
    try{ await navigator.clipboard.writeText(shareURL); alert('Link copied to clipboard!'); }
    catch(e){ prompt('Copy this URL:', shareURL); }
  });

  // Fullscreen & Pause
  $('#btnFull').addEventListener('click', () => {
    if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
  });
  $('#btnPause').addEventListener('click', () => {
    state.visualsPaused = !state.visualsPaused;
    $('#btnPause').textContent = state.visualsPaused ? '‚ñ∂ Resume visuals' : '‚è∏Ô∏é Pause visuals';
  });
  addEventListener('keydown', e => {
    if (e.key.toLowerCase()==='f') $('#btnFull').click();
    if (e.key.toLowerCase()==='p') $('#btnPause').click();
  });

  // Kick off animation
  animate();
})();
</script>
</body>
</html>
