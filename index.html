/* ===== LEAVES (autumn) — sprites + procedural, rotation, scaled smaller ===== */
class LeafSystem{
  constructor(){
    this.enabled=false; this.intensity=0;
    this.leaves=[]; this.sprites=[]; this.ready=false;
    this.spriteBias=0.7;                      // how often to use sprites vs procedural
    this.spriteScaleRange=[0.10, 0.30];       // draw sprites at 10–30% of current size
    this.fallbackColors=['#c55c18','#d79a2e','#9a5a1a','#bf6f24'];
  }
  async load(urls){
    const loads=urls.map(u=>new Promise(res=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=()=>res(null); img.src=u; }));
    const imgs=await Promise.all(loads); this.sprites=imgs.filter(Boolean); this.ready=this.sprites.length>0;
  }
  setEnabled(on){ this.enabled=on; } setIntensity(f){ this.intensity=Math.max(0,Math.min(1,f)); }
  ensureCount(){ const target=Math.floor(this.intensity*180); while(this.leaves.length<target) this.spawn(); if(this.leaves.length>target) this.leaves.length=target; }
  spawn(){
    const W=fx.width,H=fx.height;
    const scale=0.6+Math.random()*0.9;
    const vx=(Math.random()*0.6+0.3)*DPR;
    const vy=(0.8+Math.random()*1.4)*DPR;
    const rot=Math.random()*Math.PI*2, rotSpd=(Math.random()*0.02 - 0.01);
    const useSprite = this.ready && Math.random()<this.spriteBias;
    const sprite = useSprite ? this.sprites[Math.floor(Math.random()*this.sprites.length)] : null;
    const color=this.fallbackColors[Math.floor(Math.random()*this.fallbackColors.length)];
    // extra draw scale for sprites only (10–30% of current size)
    const spriteFactor = useSprite ? (this.spriteScaleRange[0] + Math.random()*(this.spriteScaleRange[1]-this.spriteScaleRange[0])) : 1;
    this.leaves.push({
      x:-20*DPR+Math.random()*W, y:-Math.random()*H*0.3,
      vx, vy, rot, rotSpd, scale, sprite, useSprite, color,
      drawScale: spriteFactor
    });
  }
  update(){
    if(!this.enabled||this.intensity<=0) return;
    this.ensureCount(); const W=fx.width,H=fx.height;
    for(let L of this.leaves){
      L.x+=L.vx+gust.val*0.35;
      L.y+=L.vy*(0.6+0.4*Math.sin(L.rot*2));
      L.rot+=L.rotSpd+0.006*Math.sin(L.x*0.01);
      if(L.y>H+30*DPR){ L.y=-20*DPR; L.x=Math.random()*W; }
      if(L.x>W+30*DPR) L.x=-30*DPR;
    }
  }
  draw(){
    if(!this.enabled||this.intensity<=0) return;
    ctx.save();
    for(let L of this.leaves){
      ctx.globalAlpha=0.9;
      ctx.translate(L.x,L.y);
      ctx.rotate(L.rot);
      const finalScale = L.scale * (L.useSprite ? L.drawScale : 1); // shrink sprites only
      ctx.scale(finalScale, finalScale);
      if(L.useSprite && L.sprite){
        const w=L.sprite.width,h=L.sprite.height; ctx.drawImage(L.sprite,-w/2,-h/2);
      }else{
        ctx.fillStyle=L.color;
        ctx.beginPath();
        ctx.moveTo(0,-8*DPR); ctx.quadraticCurveTo(10*DPR,0,0,8*DPR);
        ctx.quadraticCurveTo(-10*DPR,0,0,-8*DPR); ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,.15)'; ctx.lineWidth=0.8*DPR; ctx.stroke();
      }
      ctx.setTransform(1,0,0,1,0,0);
    }
    ctx.restore();
  }
}
